%!TEX encoding = UTF-8 Unicode
\chapter{Dalvik虚拟机}
\label{Chap:dalvik}
Dalvik是专为Android设计的一种类JVM虚拟机，是Android应用程序的实际运行平台。从恶意代码分析的角度，Dalvik上DEX文件格式的重要性，相当于Windows上PE文件格式；Dalvik指令集的重要性，相当于PC上x86指令集的重要性。在静态分析中，分析人员有一半以上的时间是在与Dalvik指令打交道；在动态分析中，绝大部分时候没有恶意代码源码，也会涉及Dalvik级的调试；如果要将一些分析工作自动化，或展开一些研究，就不得不进行DEX格式的解析。

\section{Dalvik虚拟机的设计}
JVM是一个已经设计成熟并被实践检验过的成熟的虚拟机。但在Android这样的移动平台，存在CPU性能较低、可用内存极少、电力由电池供应、没有交换空间等限制，直接使用JVM运行复杂的应用程序较为困难。此外，使用JVM还存在许可的问题。因此，Dan Bornstein设计并实现了Dalvik虚拟（名字来源于冰岛的一个小渔村）。

从虚拟级别上来说，Dalvik是一个进程级的虚拟机，提供普通应用程序的运行环境，像Java语言的JVM、.NET平台的CLR一样。从体系结构来看，Dalvik是一个基于寄存器的虚拟机。

与JVM这种基于栈的虚拟机相比，基于寄存器的虚拟机在对相同应用程序的执行上快三分之一，还能从流水线型处理器获得额外的性能提升，并有更快的加载速度和更好的容错性\cite{dalvik_analysis}。

Dalvik运行于其底层的Linux进程中，执行DEX格式文件中的Dalvik指令。通过一些库（zlib、Java核心库、openssl等）实现功能和对系统的调用，通过JNI规范调用本地代码执行。Dalvik利用Linux进程的用户ID来管理文件访问权限，并实现内存隔离，通过Linux进程间通信在应用程序之间共享数据。
\section{DEX文件格式}
\section{Dalvik指令集}
关于Dalvik指令集的主要参考文档是Android源码的dalvik/docs/dalvik-bytecode.html文件。本节的主要内容来自于该文档。

指令集的设计是一门艺术。从分析人员的角度考虑，不需要了解其中诸多细节。下面是指令集中为了便于人阅读的一些语法规则：
\begin{itemize}
  \item 两个操作数，前面是目的寄存器，后面是源寄存器
  \item 一般类型的64位opcode在32位opcode基础上加\lstinline!-wide!后缀；特殊类型opcode在一般类型opcode基础上加类型后缀，例如\lstinline!-char!、\lstinline!-int!、\lstinline!-long!、\lstinline!-float!、\lstinline!-string!、\lstinline!-object!等
  \item 对不是32位或64位操作的opcode，还加上特定后缀以说明其操作位数，例如\lstinline!/8!表示8位操作，\lstinline!/16!表示16位操作
\end{itemize}
例如，对指令\lstinline!move-wide/from16 vAA, vBBBB!，其中字段含义如下：
\begin{itemize}
  \item[move] 基本的opcode，说明指令功能
  \item[wide] 名称后缀，说明它操作64位数据
  \item[from16] 指令后缀，说明它的源操作数是一个16位寄存器
  \item[vAA] 目的寄存器，\lstinline!AA!是两个字母，表示寄存器的范围是\lstinline!v0!到\lstinline!v255!（一个字母表示4位）
  \item[vBBBB] 源寄存器，\lstinline!BBBB!是四个字母，表示寄存器的范围是\lstinline!v0!到\lstinline!v65535!
\end{itemize}
下面我们介绍Dalvik指令集，限于篇幅只列举和说明基本opcode，关于每个opcode可以适用的名称后缀、指令后缀、寄存器范围等，请参考dalvik/docs/dalvik-bytecode.html文件。
\begin{filecontents}{chapter-cn/LTXtable-dalvikopcode.tmp}
  \begin{longtable}{lX}
    \hline \textbf{基本指令} & \textbf{描述} \\
    \hline \lstinline!nop! & 空指令 \\
    \hline \lstinline!move! & 将源寄存器的值拷贝给目标寄存器 \\
    \hline \lstinline!move-result! & 将最近一次\lstinline!invoke!类型指令（函数调用）所返回的结果拷贝给指定的寄存器 \\
    \hline \lstinline!move-exception! & 将最近一次捕获到的异常值拷贝给指定寄存器 \\
    \hline \lstinline!return-void! & 在\lstinline!void!型的方法中返回，类似于C中的直接\lstinline!return! \\
    \hline \lstinline!return! & 在方法中，以指定寄存器的值返回 \\
    \hline \lstinline!const! & 将一个常量值（或常量字符串）赋给指定的寄存器 \\
    \hline \lstinline!monitor-enter! & 请求对指定目标的监视器 \\
    \hline \lstinline!monitor-exit! & 释放对指定目标的监视器 \\
    \hline \lstinline!check-cast! & 如果寄存器不能被动态转换为指定类型，就释放一个\lstinline!ClassCastException!异常 \\
    \hline \lstinline!instance-of! & 检查源寄存器中引用的值是否是指定类型数据，将结果1或0保存至目标寄存器 \\
    \hline \lstinline!array-length! & 将源寄存器指向的数组的长度取给目标寄存器 \\
    \hline \lstinline!new-instance! & 动态创建指定类型的一个新对象实例，将其引用值赋给目标寄存器 \\
    \hline \lstinline!new-array! & 动态创建指定类型的一个数组，其元素个数由源寄存器给出，将其引用值赋给目标寄存器 \\
    \hline \lstinline!filled-new-array! & 动态创建指定类型的一个数组，并以指定的值初始化，得到的结果必须使用\lstinline!move-result-object!来保存到特定寄存器，就像\lstinline!invoke!那样 \\
    \hline \lstinline!fill-array-data! & 以指定的数据填充一个数组 \\
    \hline \lstinline!throw! & 抛出一个指定的异常 \\
    \hline \lstinline!goto! & 无条件跳转至指定位置的指令 \\
    \hline \lstinline!packed-switch! & 测试寄存器的值，跳转到指定位置的指令\\
    \hline \lstinline!sparse-switch! & 测试寄存器的值，跳转到指定位置的指令，位置保存在排好序的值-偏移对中 \\
    \hline \lstinline!cmp! & 比较两个寄存器中的\lstinline!float!或\lstinline!double!或\lstinline!long!值，返回等于（0）、大于（-1）、小于（1）到目的寄存器 \\
    \hline \lstinline!if-!test & 例如\lstinline!if-eq!、\lstinline!if-lt!、\lstinline!if-ge!等，如果要比较的两个寄存器的值符合test条件，就跳转到指定偏移的指令 \\
    \hline \lstinline!if-!test\lstinline!z! & 与\lstinline!if-!test类似，但是是一个寄存器与0比较 \\
    \hline \lstinline!aget!,\lstinline!aput! & 根据索引读或者写一个数组（array）的指定元素 \\
    \hline \lstinline!iget!,\lstinline!iput! & 读或者写一个对象实例（instance）中的特定的域\\
    \hline \lstinline!sget!,\lstinline!sput! & 读或者写一个静态域（static field）中的特定的域\\
    \hline \lstinline!invoke-!kind & 函数调用，类型kind包括：\lstinline!virtual!虚方法、\lstinline!super!最近的父类的虚方法、\lstinline!direct!非静态直接方法、\lstinline!static!静态方法、\lstinline!interface!接口方法\\
    \hline unop & 单变量算术运算，例如\lstinline!neg-int!取整数的补码、\lstinline!long-to-float!将长整数转换为浮点数等等 \\
    \hline binop & 双变量算术运算，例如\lstinline!sub-int!整数相减，\lstinline!shr-long!长整数算术右移等等 \\
    \hline 
  \end{longtable}
\end{filecontents}
\LTXtable{\textwidth}{chapter-cn/LTXtable-dalvikopcode.tmp}
\section{smali语法}
