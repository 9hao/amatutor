%!TEX encoding = UTF-8 Unicode
\chapter{ARM漏洞利用}
\section{学习的目的}
目前绝大部分的智能移动终端使用ARM处理器。包括使用Android、Apple iOS、Symbian、Windows Mobile/Windows Phone、RIM OS等操作系统的手机和平板电脑。

此外，ARM还被用于大量的嵌入式设备，在PC所不能及之处发挥着重要的作用。

PC也可以使用ARM。几年前，Debian就发布了ARM版，2011年Ubuntu也开始支持ARM。Windows 8也将被微软移植到ARM上。

ARM还将向服务器市场发展，目前还出现了基于ARM和GPU的超级计算机。

可以看出，ARM设备无论是数量还是覆盖面都不逊色于PC，但ARM的安全问题，尤其是其上软件漏洞的问题，直到最近几年才开始引起人们的注意。
\section{环境和工具}
\subsection{容易获得的ARM系统}
如果需要自己编写的ARM代码实际运行起来，或者调试这些代码，就需要一个能运行ARM代码的系统。ARM的开发板并不贵，但还有更简单的方法获得这样一个系统。
\subsubsection{Android模拟器或手机}
Android的底层是Linux内核，它运行于ARM之上。使用Android学习ARM漏洞利用的优点是：
\begin{itemize}
\item 如果就是要做Android安全，这自然是最佳的选择
\item 有完善的开发工具和系统源码
\item Android模拟器的硬件（边际）成本为0
\end{itemize}
但缺点也不少：
\begin{itemize}
\item 缺乏丰富的本地软件
\item 不使用glibc库，而是自行开发的bionic，因此一些利用技巧在细节上会和Linux(on ARM)有差异
\item 目标文件的编译，或者完全静态链接，或者用NDK开发，或者与Android源码一起编译，均显繁琐
\end{itemize}

无论如何，这种零成本的环境，还是强烈推荐常备着。
\subsubsection{Debian虚拟机}
Debian早在2000年就开始了对ARM处理器的移植，目前几乎所有的软件都有了ARM版本，因此Linux用户常用的工具（例如objdump、gdb等）都可以直接在本地运行。

另一方面，qemu模拟器已经可以完整地模拟ARM处理器及其硬件平台，可以用它在x86的PC上运行ARM版的Debian。

可以直接从Debian的官网下载到其ARM安装包，但建议使用下列方案：
\hrefurl{http://www.aurel32.net/info/debian\_arm\_qemu.php}

更省事的方案是直接下载已经安装好的qemu镜像，地址是：
\hrefurl{http://people.debian.org/~aurel32/qemu/arm/}
\subsubsection{Toshiba AC100上网本}
Toshiba AC100是目前唯一一款拥有标准全键盘的ARM笔记本。它最初是为Android设计，但爱好者已经将多个Ubuntu移植到该机器上。最终，Ubuntu官方从11.10版本开始专门为这一机器提供预编译版本和软件源。

该机器在国内的型号为AC100-01B，已经不在出新货，可以从爱好者手中购买到二手的，2011年年底的行情为750元左右。

这个笔记本是目前唯一一种可以最轻松获得的真实ARM机器。拥有前面Debian虚拟机的一切优点。
\subsubsection{Nokia N900手机}
另一个hack利器是Nokia N900手机，这款老手机配置较高，采用已经被抛弃的Maemo系统，该系统是基于Linux的手机操作系统，开放性较高。N900的键盘操作性不强，系统也适合于有hack精神的人玩。
\subsection{交叉编译工具}
进行嵌入式开发时，编译工具运行于一个平台，但生成另一个平台的指令，这种编译过程称之为交叉编译，所使用的编译工具又称之为工具链。

在x86上编译ARM代码最常用的工具链由CodeSourcery公司免费提供，有Windows版本和Linux版本，其下载地址是：\hrefurl{http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/editions/lite-edition}

此外，在基于Debian的系统（例如Ubuntu）中，也可以通过apt-get install gcc-arm-linux-gnueabi直接获得一个交叉编译gcc。

Android的NDK中实际上也包含了完整的工具链，包括编译器、调试器、binutils等。它有Windows和Linux版本，下载地址是：
\hrefurl{http://developer.android.com/sdk/ndk/index.html}
然而NDK也有不足，即只能为Android编译代码，也只能使用其提供的有限的库接口。对后面一个问题，如果需要编译使用了Andrid系统中较底层API的ARM程序，建议使用agcc工具，具体可以看我写的文章：
\hrefurl{http://blog.claudxiao.net/2011/10/android\_agcc/}
\subsection{反汇编和反编译工具}
工具链包含了很多的工具，如果静态反汇编，可以使用objdump；如果动态运行起来，在gdb中也可以使用disasm反汇编。

最ARM反汇编支持最好的工具是IDA Pro，但它是商业软件，自由开源的反编译工具可以考虑radare：
\hrefurl{http://www.radare.org/y/}
或者smiasm：
\hrefurl{http://code.google.com/p/smiasm/}
但radare和smiasm对Thumb、Thumb-2指令集的支持都不强。

事实上，ARM的指令编码并不复杂，自己写一个ARM反汇编器的工作量远小于想象。

目前ARM的反编译工具只有随IDA Pro 6.2一起发布的Hex-Rays ARM Decompiler，是一款昂贵的收费软件。
\subsection{远程调试}
gdb远程调试

IDA远程调试请参考：
\hrefurl{http://bbs.pediy.com/showthread.php?t=141739}

\section{ARM体系结构}
\subsection{ARM指令集}
ARM同时是三个不同事物的名字：
\begin{itemize}
\item 一个公司
\item 一种体系结构
\item 一系列CPU产品
\end{itemize}
这一章主要是指第二种含义。

ARM是32位RISC结构，在ARMv5以后，基本采用Harvard结构，与传统的冯诺依曼结构不同的是，数据和代码被最大程度隔离了。既便于数据段保护的x86也有本质区别，ARM的代码和数据采用不同的总线传输（并因此获得并行而提速）。其数据段自然不能被执行。

\subsubsection{寄存器}
对程序员可见的寄存器主要是r0到r15共16个，不同的寄存器有不同的用途，将在下一节说明。

此外，有程序状态寄存器PSR，其中包括算数逻辑运算标志、执行状态位、当前中断号等。

\subsubsection{数据操作指令}
基本形式是：
\begin{lstlisting}[numbers=none]
<opcode>{<cond>}{S} <Rd>, <Rn>{, <operand2>}
\end{lstlisting}
其中：
\begin{itemize}
\item[opcode] 比如MOV、ADD，与x86类似，具体可以查ARM手册
\item[cond] 可选的条件码。条件执行是ARM的特色之一，几乎所有的ARM指令都可以加上条件码，实现条件执行。例如，EQ、LE等
\item[S] 可选的S位，如果该条指令会更改PSR，则应置上S位
\item[operand] 操作数可以是寄存器，也可以是一个右值（后面会说明），每条指令有多少操作数，分别是什么含义，应查手册
\end{itemize}

ARM中的右值操作数可以是一个寄存器、一个立即数，或者一个寄存器的移位。例如，右值R1, LSL \#2由R2的值逻辑左移2位得到，右值R1, ASR R3由R1的值算术右移R3位得到。

\subsubsection{分支跳转指令}
\begin{itemize}
\item[B] 直接跳转到一个地址，唯一的参数是12位立即数，与x86中的jmp功能一样
\item[BL] 将下一条指令地址（即返回地址）赋给LR寄存器，然后跳转到参数指定的地址，参数是一个12位立即数。BL与x86中的call功能一样
\item[BX] 参数是一个寄存器，跳转到该寄存器指向的地址
\end{itemize}
所有这些分支跳转指令都可以使用条件码，成为相应的条件跳转指令。

\subsubsection{内存访问指令1}
ARM使用简单的访存模型，所有内存读写都通过LDR和STR两条指令完成，而且只能在寄存器与内存之间读写，不能直接从内存读写到内存。LDR和STR都有一个可选的后缀B，不选时按字（4字节）读写，选择B时按字节读写。其第一个参数是寄存器，第二个参数是内存地址。

\subsubsection{寻址方式}
第一类寻址方式：
\begin{itemize}
\item 寄存器加上立即数偏移：[reg, \#$\pm$imm12]
\item 寄存器加上寄存器偏移：[reg, $\pm$reg]
\item 寄存器a加上移位后的寄存器b偏移：[rega, $\pm$regb, shift]
\end{itemize}
这些地址符号后面可以选择一个叹号：!。如果加上，表明先根据寻址规则修改寄存器，然后根据寄存器中的值访问内存；如果不加叹号，表示直接根据寻址规则访问内存。

第二类寻址方式则是先根据寄存器中的值访问内存，然后按照相应的规则更新寄存器：
\begin{itemize}
\item 访存后，寄存器加上立即数：[reg], \#$\pm$imm12
\item 访存后，寄存器加上寄存器：[reg], $\pm$reg
\item 访存后，寄存器a加上移位后的寄存器b：[rega], $\pm$regb, shift
\end{itemize}

\subsubsection{内存访问指令2}
还可以一次性读写多个字：
\begin{lstlisting}[numbers=none]
LDMcdum reg!, mreg
STMcdum reg!, mreg
\end{lstlisting}
其中：
\begin{itemize}
\item[cd] 可选的条件
\item[um] 访问模式，分别为IA读写后增加寄存器值、DA读写后减少寄存器值、IB读写前增加寄存器值、DB读写后增加寄存器值
\item[!] 表示会修改寄存器，修改方法参考um
\item[mreg] 支持一次指令多个寄存器，例如{R0-R3, R7, R10}
\end{itemize}

\subsection{ATPCS}
\subsubsection{名词解释}
例程(routine)、子例程(subroutine)：对于一段可以调用、可以返回、保证栈平衡的代码片段，例程指调用者，子例程指被调用者。

过程(procedure)：不返回结果值的例程。

函数(function)：返回结果值的例程。

变量大小、内存对齐、字节序、复合类型等略。
\subsubsection{寄存器的用途}

ARM中有16个通用寄存器r0 – r15。其中：
\begin{itemize}
\item[r0 – r3] 用于传递参数、返回函数结果，因此又名a0 – a3。在例程内部也被用于保存临时结果
\item[r4 – r11] 用于保存例程内的局部变量值，又名v0 – v8。其中，r9(v6)是一个平台相关的值，不同的ARM平台必须为这个寄存器赋予特殊的含义
\item[r12 – r15] 有专门的用途，后面介绍。常用别名：IP、SP、LR、PC
\end{itemize}
\subsubsection{栈结构}

r13（SP）是栈指针。ARM中使用向下的满栈（full-descending），即SP始终指向最后一个已进入栈的数据，每次压栈时，SP自减需要的内存大小，然后将值存到SP新的位置。

也就是说，对栈的push相当于STMDB，对栈的pop相当于LDMIA，但一般不用这个后缀，而用STMFD和LDMFD。

SP的值应在栈的有效区间内，且mod 4 = 0。栈上有例程的调用帧结构。不要轻易地修改这个值。

\subsubsection{子例程调用}

ARM和Thumb指令集均有一个BL指令，它的操作是：将BL指令顺序下一条指令的地址（即返回地址）送入链接寄存器LR(r14)，然后将调用的目的地址（即子例程地址）送入寄存器PC(r15)。

如果在Thumb中调用BL，则LR的第0位被设为1，否则被设为0。（因为指令地址要4字节对齐，因此LR的第0和1位都没有用。）

子例程返回很简单，将LR的值送入PC即可。

任何模拟上述过程的指令序列也会起到BL的效果，例如：mov LR, PC; BX r4。注意，任何时候读PC，得到的值是当前指令地址+8（why?请自己google）。

\subsubsection{结果返回}
\begin{itemize}
\item 不超过4字节的结果，一律用r0返回
\item 超过4字节的基本类型，继续用r1, r2, r3
\item 超过4字节的复合类型，或动态大小的结果，存储在内存中，并将其地址作为调用参数之一传入
\end{itemize}
\subsubsection{参数传递}

使用r0 – r3传递参数，如果不够，使用栈。

语言中的数据类型会按照相关标准转化为机器数据类型。
\section{ARM漏洞利用的特点}
与x86相比，ARM下要做到漏洞利用存在以下问题：
\begin{itemize}
\item 从v5开始，ARM普遍采用哈佛结构，数据段不可执行
\item 函数调用时，参数传递不再通过栈，而是使用寄存器
\item 返回地址按照ATPCS是通过LR寄存器传递，大部分被掉用函数会在其代码开始时将LR再次保存到栈上，在返回前从栈中直接取回至PC寄存器
\item 由于体系结构的本质区别，作为跳板的指令无法使用x86下常见的那些，而要根据实际需要来寻找
\end{itemize}
但也有好的消息。在Windows/x86平台引入DEP以后，因为代码部分的不可执行，出现的ret2libc和ROP等技巧，其思路也可以用于ARM。此外，ARM单条指令的描述能力是超过x86的，所以要寻找到合适的跳板指令序列并不是太难。

ARM漏洞利用是一个新的领域，目前参考文献较少，主要有\cite{arm_exploiting_linux}、\cite{arm_stack_exploitation}、\cite{arm_exploitation}、\cite{arm_ropmap}和\cite{arm_alphanumeric}。
\section{一个示例}
下面我们看一个实际的例子。
\section{Ret2ZP攻击}
\section{zergRush漏洞分析}
